## 哲学

### 编程语言的实质

- 使用 define 固定下来某种特殊的结构作为代码世界中的命名基础。
- 使用 Lambda Calculus 作为计算的最根本模型。
- 代码世界中的数据与现实世界中的数据一一对应。
- 代码世界中的数据用 quote 作为和代码本身的区分，但是部分常见的数据拥有额外的语法糖形式，如 int 类型直接写，字符串类型具有 "" 的标志。
- 基于上述真实世界中的数据是 atom 的不可分的概念，通过 cons 链接这些数据得到新的结构。
- 因此映射需要考虑的变量域只有两种：Data 和 Construction.
- 



### 内容界定

世界的素材具有无法分割的 atom，我们用 cons 链接 atom 构成不同的结构，cons 的缩略语法糖形式为一个点。

#### List
定义空列表标志符为 '()




## (0. Introcution)




Scheme 语言基于 *Lambda Calculus* 的理念，实现了其中的 *L-map* 的定义和 *Calculate*. 

值得注意的是，对于最 *Atom* 的数据从机制上似乎是可以简单解决的，但是 *List* 的数据就需要额外的结构，考虑到重新叙述的困难，以及一些代码实现机制的复杂性，这里简要介绍几个机制。

- quote：考虑到代码和数据层需要一个链接，因此引入了一个叫做 quote 的概念，将 quote 后面的语句整体看作一个单独的对象。但是注意，后面的语句不一定就是 Scheme 中的表达式，也就是有可能没有意义。

- parse：很多内容隐藏了一个转换的过程，将一个符合 S 表达式的语句转化成 S 表达式本体。这个过程是 quote 的解引用，但是隐含在很多内容中。

- Evaluate：把 Procedure 尝试求值的过程

- pattern match in *l-map*：*list* 在 scheme 中有一个构造形式的理解：
	$$a . b . c . ()$$
	然后为了简化这个 cons 的过程并于数学标准的 list 对应起来，简写成 '(a b c) 的形式。
	
	其中，. 代表 cons 的中缀育发烫，cons 是一个二元运算，操作在 quote 类型上，直接将他们缀在一起成为新的 quote.
	
	也就是标准形式的序列 '(1 2 3 4 5 ... n) 等价于连缀式 ' cons 1 (cons 2 (cons 3 (cons 4 ...))) 
	或者等价于中缀语法糖形式的 ' 1 . (2 . (3 . (4 . (后略))))，这就为针对上述不同表达形式的 *list* 提供了 *l-map* 自变量的识别思路.


### List

基于上述形式的



### L-map

*l-map* 在 *scheme* 中通过以下方式实现：
```Scheme
(lambda (args...)
  body)
```
其中，参数列表默认支持 *list* 类型。

也就是说，调用 l-map 的时候，参数的识别实际上容易出现歧义，为了解决变参的问题，把 f 后面的全部内容先用 list 打包，之后作为参数列表传递。

实际上，L-map 的调用语法 'f arg1 arg2 ... 是语法糖：
```Scheme
(let (pattern-match f.variables consAll arg1 arg2 ...))
```
其中，pattern-match 理解为对 f 的自变量名称的解包。

consAll 是把右侧内容连接成列表，实际上我猜想是某种 lfold 的 map 操作.

但是如果直接针对引用的 list 类型进行操作，那么传入的参数应该是 (x)，此时传入的数据表达式应当用 quote 标记。
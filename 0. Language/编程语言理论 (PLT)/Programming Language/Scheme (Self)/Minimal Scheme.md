# Minimal Scheme

- [Minimal Scheme](#minimal-scheme)
- [0. 引言](#0-引言)
  - [1. 造物主的哲学](#1-造物主的哲学)
  - [Lambda Calculus](#lambda-calculus)
    - [1. 基本世界的抽象](#1-基本世界的抽象)
    - [2. 第一推动力的抽象](#2-第一推动力的抽象)
      - [自由变量和限制变量](#自由变量和限制变量)
      - [调用 l-map 的规则](#调用-l-map-的规则)
- [1. 使用 lambda calculus 构造世界](#1-使用-lambda-calculus-构造世界)
  - [1.1 世界模型](#11-世界模型)




# 0. 引言

考虑自己是一个造物主，创造一个可以运转的世界（尤其是编程语言世界），现在，Scheme 将为你提供必要的创造世界的素材和工具。本部分，每一个哲学观点我尽可能用三个方面的内容解释：

1. '哲学概念解释
   此部分先忽略

2. 真实世界解释
   
3. 底层（便数学 or 底层一点？）解释
   

## 1. 造物主的哲学

世界的哲学：

基本的世界要有什么？

1. 物体 atom
   世界是需要有切实存在的素材的，不然讨论没有意义。 生活里可能叫这个概念为事物。
   
   在计算机世界里我们叫它为数据，在 Scheme 里叫做 value。数学世界里可以理解为 domain.

   此处先不考虑说多个物体的堆积是不是整个物体的概念。


2. 运动 map
   犹如一潭死水的世界是没意思的，事物需要进行运动。

   Objective-Programming 的哲学在于描述某种物体怎么运动。FP 的哲学在于规定好良好的运动规则。数学里意味良好定义的函数的作用是确切的，至少我们对它的定义域、值域很确定。


为了能有上述的东西，我们需要拥有成为造物主的能力：

我们首先抽象出上述两个概念，为数据、表达式。接下来，我们加入一些造物主的第一推动力。


## Lambda Calculus

### 1. 基本世界的抽象
(Lx[Expression])

保留 lambda calculus 的基本内容：

映射的表达、圆括号代表结合为一个整体、方括号是表达式。

- l-map
  (\x[Expression]) 类比喻于 f: x -> Expression 这个映射。
  实际上，python 语言里直接用 lambda x : Expression，部分编程语言直接用箭头了。

> 此处可以补充一些哲学理解，映射本身是一种把左侧传入的自变量 x 的数值代换到右侧变量的一种规则，使用括号传入数值之后会得到将右侧表达式（因变量）里的 x 代换成具体数值的结果。
> 
> 也就是映射本身更像一种替换规则，映射调用则是得到运动后的结果。


于是，为了我们描述的世界是一个大一统的世界。基于上述映射表达形式和基础数据，我们定义一个略大于具体数据的概念，以包括上述所有内容，叫做一个 L-term。
  
  - 数据是 L-term.
    > 所有变量是 L-term.

  - 如果 lambda calculus 下的 l-map 的因变量是 L-term，那么这个映射是 L-term.
    注意到，由于所有因变量天然是 L-term，所以映射天然是 L-term.

    > 这条保证了一些数学概念上作用于 map 上的 functor 仍然是我们讨论的 L-term.

  - L-term 复合之后是 L-term.

  
注意到，我们的 L-term 只关心具体的值，身为造物主的我们创造好世界运转的规律，接下来值（具体数据）是唯一能被具体观测到的事物。

用 lambda calculus 的语言可以表达上述内容，但是不重要。强调一点，去掉括号的内容是一种运动规则，也就是 f 的描述。

### 2. 第一推动力的抽象

我们可以尝试总结一些运转规律，仅仅用映射和 lambda calculus 即可得到他们。由于我们的 L-term 想要包含数据、映射和基本的 lambda calculus 规则。

#### 自由变量和限制变量

我们关心的更多是具体的数据，计算过程是指将数据代入计算规则（表达式）而得到新的数据。

所有表达式都是对具体数据的计算规则的抽象，一个 l-map 就是额外声明了这个表达式中哪部分是可以被自由代替的：

如加法 1 + 2 可以抽象为 表达式 a + b。其中 a，b 分别替换成 1 2 的时候，对应了我们想要的具体数据。

我们将这个替换的过程书写为：(l-map)[a := 1] 的形式。

注意到，这种替换的过程中，哲学观念上，我们不会再认为左侧 a 是随意可变的了，而是所有的 a 都会被尝试找到并替换。为了更好的描述哪些变量在当前求值的过程中是自由的、哪些是不自由的，我们引入以下的概念。

定义我们的 L-term 系统中的两类变量：自由变量和限制变量，这里的自由与否是指被替换的自由程度。

我们认为，当前计算过程中的限制变量是不需要在这个阶段关心的，也就是不能被随意替代的。
> 比如 a + b 代换成 1 + 2 实际上会有一个先后顺序，比如我先代换 a 的时候，b 的部分就不能动，也就是代换 a 的时候，a 是自由可以被替换成值的，但 b 不可以自由替换。
> 也可以理解为 a 才是当前阶段的变量，b 只是一个符号。
> 表达式中含有的变量只可能是 l-map 的自变量，叫自由变量，和更外层才会出现的变量，在当前环境叫的限制变量。

这个定义有利于我们管理我们的变量符号命名系统，防止出现歧义。

符号上，一个 L-term 中的自由变量写作 FV(L)，限制变量写作 BV(L).

- 限制变量：
  首先，任意一个单独的自变量本身的 L-term 是限制的，因为它是某个具体的值的反应。

  另外，l-map 的自变量会使得表达式内部出现的同名变量变得限制。由于我们的系统不存在完全自由的变量，总是假设了表达式中的变量在外部能够找到对应。
    
  > \a\b\c.....\k   a + b + c + d + ... + k.
  > 在观察最内侧 \k[a + ... + k] 的时候，a, b, c... 等不同名变量都是限制的，虽然他们等待被外部传入值，但是传入之后就是具体的值，因此是收到外部 l-map 世界的限制。

  也就是在只观察某个部分的时候，已经在表达式中出现的不同于自变量的变量名是限制的。

  > f(x) = x + y 的时候，我们默认 y 是某个外部已经知道结果的数值，不然，就该定义为一个二元函数。

  f(x, y) 中，y 就不自由，z 就自由。

- 自由变量：
  意为这个变量可以随便更改名称，不会产生任何影响。
  
  首先，我们的变量系统中，名称不同的自由变量默认互相独立。

  我们默认了所有的 x, z 都是取自自由变量定义域的，因此f(x) 和 f(z) 没有区别。



- L-term 计算的本质是从自由变量（可以直接被简单观测来求值的一类对象）不断通过替换、计算，消除表达式中的限制变量（形式变量），以得到最后的自由变量的计算过程。
  
- 也整个运算本身就是一个极其复杂且可以发展、消去的函数，我们最后尝试得到一个最简单的从输入数据到结果数据的函数，接着带入数据就可以得到结果。


首先，注意 l-map 中的变量名称是自由的，意思是这个变量和表达式随便变成另外一个不与内部表达式已有的变量产生歧义的变量都是可以的。我们叫这种可以被随意替换的变量为自由变量，l-map 表达式中天然含有的不与当前 map 的自由变量重名的变量叫做限制变量 bound variable.

> x -> x + y    ==    z -> z + y.
> x -> x + y    !=    y -> y + y.
> 第二条就是因为改变了函数的本意，

注意到，l-map 整体看做一个 L-term 是绝对不可能包含与自由变量同名的限制变量的，这点从 l-map 的定义规则上就可以理解。（即以 x 为自由变量的 map 带入 x 后是不可能还包含自由变化的 x 的）

#### 调用 l-map 的规则

所以解决了变量的歧义问题之后，我们额外定义一个调用规则，对应数学上的调用 f 得到 f(x)。

简单来说，l-map 的调用，写作 M[x := N]，是指把左侧 L-term 里的限制变量 x 替换成 N.

有关 FV 替换的基础规则有：

- FV(A)[x := M] = A[x := M]
- FV(A - {x})[x := M] = A

更为严谨的，有以下的辨析：

- x[x := M] = M.
  左侧限制变量 x，
- y[x := M] = y. (x != y)
  
- (AB)[x := M] = (A[x := M]B[x := M])
  寻找左侧的限制变量，等价于寻找左侧表达式内部的限制变量 x。

- (\x[A])[x := M] = (\x[A]).
  f(x | y = M) = f(x)

  注意到 FV(\x[A]) = FV[A] - {x}，因此尝试寻找左侧的限制变量 x 并替换成 M，A 中不存在限制变量 x，因此替换不会造成改变。

  > 或者理解为，在 M 不是限制变量的前提下，直接替换左侧所有变量 x 也不会有影响。
  > 即，替换本身不会造成歧义的前提下，随意替换自由变量的符号是没有影响的。

- (\x[A])[y := M] = (\x[A[y:=M]]). (x != y)
  类似于 f(x, y | y = M) 退化成 f(x, M) 的意思.

  尝试寻找左侧中的限制变量 y 进行替换，注意到左侧 L-term 的限制变量可能出现在 A 中，进而直接替换即可。
  

# 1. 使用 lambda calculus 构造世界

## 1.1 世界模型

“我们只是在用语言尝试理解世界，尝试共鸣。”——慕青QAQ

- 真实世界：考虑外界、具体世界、实在的世界等等概念。
  这个世界包括了所有概念，物质的、精神的等等。

  具体的实在物叫是 object。
  
  描述 object 变化规则的是 map。
  
  让 map 作用得到结果的是第一推动力 let.


- 语言世界：指代物体的一套符号系统。比如文字语言、编程语言。


lambda calculus 是描述映射规则的语言。可以适用于任何结构的映射，包

- 两层世界的模型

  - 语言世界（包含编程语言）
  
  
  - 实在物体（对应的本身的东西）



















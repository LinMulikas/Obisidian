矩阵是一种 [[Construction]]，用来直接表示映射、向量。矩阵乘法作为 [[Map]] 作用的一个对应，之后扩充了对于点乘等乘法的支持。以下讨论内容限定在有限维向量空间。

本文默认读者拥有一般的线性代数基础。

## [[(1. Represent of Vector, Linear Map)]]

首先，我们一直在做的事情是把抽象的东西用数字写出来，这包含了表示的基本思想，而向量空间的事物包含了向量、映射，下面先考虑这两种事物的*表示*，也就是*矩阵*的写法（默认一行、一列的也是矩阵）。

向量拥有多个元素，我们书写向量的时候可能只有四种写法，考虑默认从上到下或者从左到右，我们就只有两种写法。

考虑映射实际上必然包含两个部分，domain 和 codomain，对于有限维向量空间，一个自然的想法是拆解映射在 domain 上的作用，或者拆解它在 codomain 的作用。更常见的，我们定义映射的时候对 domain 的信息知道更多。

考虑映射作用于自变量、映射复合映射的写法习惯了由先到后——从内向外（从右向左）的对应，我们如果想让他们的*表示*之间的作用也能保持这种优良的性质，可能需要额外的操作。

以下内容中，用*矩阵*一词来代表上述事物的*表示*。

### 1. 向量的表示关键

向量的表示方法略了。值得注意的是，不管是行的写法还是列的写法都可以很好的定义线性、加性等内容。

### 2. 映射的表示关键

考虑我们在微积分里已经接触过：单变量单值，多变量单值，向量函数（多变量多值），我们尝试让矩阵能够尽可能保持上述的已经接触的素材。值得注意的是，单变量单值、多变量单值都可以看成多变量多值的特殊情况，但是为了层层递进，我们一个个考虑。

#### 1. 单变量单值

略

#### 2. 多变量单值

考虑一个最抽象的写法，我们把向量记作 $\vec x$，那么会得到一个形式：
$$f(\vec x)$$
考虑到微积分里我们习惯了
$$f(x_1, \ldots, x_n)$$
的写法，我们尽可能保持这种结构。

#### 3. 多变量多值

考虑到多变量多值函数本身可以写作 $\vec f$，那么在给定 2 的写法的基础上，把多变量函数写成
$$\vec f = [f_i]$$
是自然的，其中方括号表示某种规定了的向量写法——也就是把多变量多值函数拆解，变成多个多变量单值函数是很自然的。


### 3. 基本思路

考虑了上述三种结构后，我们首先要做的事是确定一个向量的写法。实际上线性代数里已经学过了用竖着写的方式表示天然的向量。但是我们也可以考虑行的写法，下面专门给出用行的写法的推理过程：

1. 向量表示的思路：
	用行表示，已经确定了
2. 映射表示的思路：
	1. 单单：不影响
	2. 多单：我们发现被作用的向量可以自然的直接在括号里展开，
	3. 单多：我们可以把函数拆解在 codomain，作为多个单变量函数的堆砌。
	4. 多多：我们发现可以把函数展开
		 $$\vec f = (f_1(\cdot),\  \ldots,\ f_n(\cdot))$$
		其中，为了强调每个小的 f 都是多变量函数，我用单点表示被作用的对象。

接下来，我们开始用矩阵的写法：

1. 向量：
	略，用行的形式写。
	$$[\vec x] = (x_1\ \ldots\ x_n)$$
2. 映射：
	1. 单单：略
	2. 多单：
		 注意到，有：
		$$f(x) \sim [f][\vec x] = [f](x_1\ ...\ x_n)$$
	3. 单多
		 考虑到
		 $$\vec f(x) = [f_i(\cdot)](x)$$
		 注意，我们这里采用了单点的写法来表示右侧括号内的 x 应当直接带入单点的位置。
		 
	4. 多多：
		 首先考虑看作单多的函数并展开书写，接下来再把自变量展开。
		 $$\vec f(\vec x) = [f_i(\cdot)](\vec x) = []$$
		 考虑我们的向量是横着写，并且我们默认了*直积*之类的东西书写的时候，从第一个东西到最后一个东西都是从上到下、从左到右的。
		 
		 我们得到的结果作为向量本身必然是*行排列*的，但是我们发现按照行展开书写的时候，如果要把上述操作具体表示出来，接下来应该是把自变量展开，这就会导致两个都是行变量的展开很宽，而且这种思路的话我们很难去区分自变量的维度和因变量的维度，如果不添加额外的括号之类的标记。
		 
		 我们要么尝试将自变量在带入的时候换一个方向展开，那么我们记住代入的时候需要把自变量换个方向就行。我们称行的写法、列的写法互为*转置*。

从以上的内容，我们建立了行的写法，但是还没有定义有关矩阵的*乘法*以让乘法和作用能够对应起来。但是值得注意的是，在上述的内容里，我们已经发现了为了保持写法不添加额外的机构，必须在带入的时候采取转置的操作。

然后就会发现，多对一函数带入向量其实和逐点乘之后求和缩并的操作一致。我们乘这个操作叫做*点乘*。

### 4. 具体实现的例子

常用的线性代数是列写法的的例子。

我们首先考虑线性函数，线性函数而言，可以考虑把它的作用拆解在 $\vec x$ 的基上，自然的能够定义出一个多对多的函数，那么我们继续从简单到难，将它拆解成多对一的函数的堆砌。

多对一的函数按照列堆砌，我们先默认这个事实。然后考虑一个多对一函数怎么写。保持微积分的横着的括号展开作为调用的写法，另外我们注意到多对一的函数其作用可以拆开为对多个基的作用，因此自然的可以直接写出来一个东西。


略略略。

## [[(2. Derivative of Matrix Notation)]]

万能思路：

全部拆解成单独的结构，额外计算排布规则。

万能思路之下，*Ricci Calculus* 的记号很有用。

为了用上下标表示矩阵的全部内容，我们首先默认了点乘与指标缩并的等价。
但是我们注意到上述过程中，函数的作用（指单独考虑对每个基对作用）其实蕴含了驻点乘的概念。

此外，我们需要对转置的操作进行额外的定义，

函数思路：

把一些含混不明的点乘、作用等等都写成函数的标准写法，其中，点乘作为两个位置的函数，其求导规则是分别求导之后求和。

然后先推导出基本的函数求导规则，然后推导运算的求导规则。

*惊喜*
惊喜的发现，转置对于矩阵的作用等价于内外反转。
$$Ax \sim A(x^T)$$
把 $x^T y$ 看作 $x^T(y^T)$ 就很自然了。

也就是说，把向量作为自变量的过程蕴含了转置。对于最简单的点乘，因为是数字，所以直接转置不影响结果，但是对于矩阵之类的，需要转置回去。

转置算子联系了点乘，点乘把向量扩展到了函数。注意到点乘的结果是数字，内外可以任意颠倒。

写成调用形势后，对内部求导等于外界，对外界求导也等于内界。

事物失去了自变量的概念，只有映射的相互复合。
$$[A(x)]^T = x(A)$$


$$x^TAx = x(Ax) = x(A(x^T))$$

向量的转置表示把向量函数化

$$x^T??? = x(???)$$

矩阵乘向量等同于把向量的转置带入矩阵对应的映射



第一部分求导默认结束，引入占位符

$$\cdot(A(x^T)) + x(\frac{d A(x^T)}{dx})$$


*映射单子的角度*

大概是那个对某个东西求导就要把它看成自变量，进而是在上面的乘法表达式中找到自变量的转置然后作为占位符消去。

右侧的部分不会变化，左侧的部分取转置

